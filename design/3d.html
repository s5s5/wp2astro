<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 粒子变形：修复版</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505; /* 深邃宇宙黑 */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
        }
        #ui-container {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            user-select: none;
            z-index: 10;
        }
        #title {
            color: rgba(255, 255, 255, 0.9);
            font-size: 24px;
            letter-spacing: 4px;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.6);
            margin-bottom: 10px;
        }
        #status {
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 20px;
            display: inline-block;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.4);
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="ui-container">
    <div id="title">PARTICLE MORPHING</div>
    <div id="status">INITIALIZING...</div>
</div>
<div id="controls">自动旋转展示中 | 鼠标上下移动可倾斜视角</div>

<!-- 引入 Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
  (function() {
    // --- 配置参数 ---
    const MORPH_PARTICLE_COUNT = 6000;
    const BG_PARTICLE_COUNT = 4000;
    const MORPH_DURATION = 2.0;
    const STAY_DURATION = 2.5;
    const SIZE = 4.0;

    // --- 状态管理 ---
    const shapes = [];
    const shapeNames = ["CUBE", "MÖBIUS STRIP", "SOCCER BALL", "UFO", "PLANE", "ROCKET", "SHIP", "MONKEY HEAD"];
    let currentShapeIndex = 0;
    let nextShapeIndex = 1;
    let timeAccumulator = 0;

    const uiStatus = document.getElementById('status');

    // --- 1. 场景初始化 ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 2, 6.5);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    if (document.body.querySelector('canvas')) {
      document.body.removeChild(document.body.querySelector('canvas'));
    }
    document.body.appendChild(renderer.domElement);

    // --- 通用材质 ---
    function createLightTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 32;
      canvas.height = 32;
      const ctx = canvas.getContext('2d');
      const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
      grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
      grad.addColorStop(0.3, 'rgba(255, 255, 255, 0.6)');
      grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 32, 32);
      return new THREE.CanvasTexture(canvas);
    }

    const commonMaterial = new THREE.PointsMaterial({
      size: 0.15,
      map: createLightTexture(),
      vertexColors: true,
      transparent: true,
      opacity: 0.85,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      sizeAttenuation: true
    });

    // --- 2. 独立的背景星云系统 ---
    const bgGeometry = new THREE.BufferGeometry();
    const bgPositions = new Float32Array(BG_PARTICLE_COUNT * 3);
    const bgColors = new Float32Array(BG_PARTICLE_COUNT * 3);
    const bgPhases = new Float32Array(BG_PARTICLE_COUNT);

    for (let i = 0; i < BG_PARTICLE_COUNT; i++) {
      const r = 2.0 + Math.random() * 23.0;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos((Math.random() * 2) - 1);

      bgPositions[i*3] = r * Math.sin(phi) * Math.cos(theta);
      bgPositions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
      bgPositions[i*3+2] = r * Math.cos(phi);

      bgColors[i*3] = 0.5;
      bgColors[i*3+1] = 0.5;
      bgColors[i*3+2] = 0.5;

      bgPhases[i] = Math.random() * Math.PI * 2;
    }
    bgGeometry.setAttribute('position', new THREE.BufferAttribute(bgPositions, 3));
    bgGeometry.setAttribute('color', new THREE.BufferAttribute(bgColors, 3));

    const bgSystem = new THREE.Points(bgGeometry, commonMaterial);
    scene.add(bgSystem);


    // --- 3. 变形粒子系统核心 ---
    const morphGeometry = new THREE.BufferGeometry();
    const currentPositions = new Float32Array(MORPH_PARTICLE_COUNT * 3);
    const currentColors = new Float32Array(MORPH_PARTICLE_COUNT * 3);

    for(let i=0; i<MORPH_PARTICLE_COUNT; i++) {
      currentColors[i*3] = 1.0;
      currentColors[i*3+1] = 1.0;
      currentColors[i*3+2] = 1.0;
    }

    morphGeometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
    morphGeometry.setAttribute('color', new THREE.BufferAttribute(currentColors, 3));

    const morphSystem = new THREE.Points(morphGeometry, commonMaterial);
    scene.add(morphSystem);


    // --- 4. 形状生成与优化 ---

    function createShapeData() {
      return {
        positions: new Float32Array(MORPH_PARTICLE_COUNT * 3),
        intensities: new Float32Array(MORPH_PARTICLE_COUNT)
      };
    }

    function sortPoints(posBuffer, intBuffer) {
      const tempArray = [];
      for(let i=0; i<MORPH_PARTICLE_COUNT; i++) {
        tempArray.push({
          x: posBuffer[i*3],
          y: posBuffer[i*3+1],
          z: posBuffer[i*3+2],
          i: intBuffer[i]
        });
      }

      tempArray.sort((a, b) => {
        if (Math.abs(a.y - b.y) > 0.2) return a.y - b.y;
        if (Math.abs(a.x - b.x) > 0.2) return a.x - b.x;
        return a.z - b.z;
      });

      for(let i=0; i<MORPH_PARTICLE_COUNT; i++) {
        posBuffer[i*3] = tempArray[i].x;
        posBuffer[i*3+1] = tempArray[i].y;
        posBuffer[i*3+2] = tempArray[i].z;
        intBuffer[i] = tempArray[i].i;
      }
    }

    function fillRemainingAsGhost(posArr, intArr, startIndex) {
      if (startIndex >= MORPH_PARTICLE_COUNT) return;

      if (startIndex === 0) {
        for (let i = 0; i < MORPH_PARTICLE_COUNT; i++) {
          posArr[i*3] = (Math.random()-0.5); posArr[i*3+1] = (Math.random()-0.5); posArr[i*3+2] = (Math.random()-0.5);
          intArr[i] = 0.15;
        }
        return;
      }

      for (let i = startIndex; i < MORPH_PARTICLE_COUNT; i++) {
        const targetIdx = Math.floor(Math.random() * startIndex);
        const r = 0.2 + Math.random() * 0.6;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);

        posArr[i*3]   = posArr[targetIdx*3]   + r * Math.sin(phi) * Math.cos(theta);
        posArr[i*3+1] = posArr[targetIdx*3+1] + r * Math.sin(phi) * Math.sin(theta);
        posArr[i*3+2] = posArr[targetIdx*3+2] + r * Math.cos(phi);

        intArr[i] = 0.15;
      }
    }

    // --- 几何生成辅助函数 (修复版) ---

    // 修复: 确保包含线段终点，解决“缺角”问题
    function addBoxPoints(posArr, intArr, idxRef, w, h, d, cx, cy, cz) {
      const hw = w/2, hh = h/2, hd = d/2;
      const v = [
        [cx-hw, cy-hh, cz-hd], [cx+hw, cy-hh, cz-hd], [cx+hw, cy-hh, cz+hd], [cx-hw, cy-hh, cz+hd],
        [cx-hw, cy+hh, cz-hd], [cx+hw, cy+hh, cz-hd], [cx+hw, cy+hh, cz+hd], [cx-hw, cy+hh, cz+hd]
      ];
      const edges = [[0,1], [1,2], [2,3], [3,0], [4,5], [5,6], [6,7], [7,4], [0,4], [1,5], [2,6], [3,7]];

      edges.forEach(edge => {
        const p1 = v[edge[0]];
        const p2 = v[edge[1]];
        const dist = Math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2);
        const numPoints = Math.max(2, Math.floor(dist * 6));

        // 【修复】改为 k <= numPoints，确保覆盖终点
        for(let k=0; k<=numPoints; k++) {
          if (idxRef.val >= MORPH_PARTICLE_COUNT) return;
          const t = k/numPoints;
          posArr[idxRef.val*3] = p1[0] + (p2[0]-p1[0])*t;
          posArr[idxRef.val*3+1] = p1[1] + (p2[1]-p1[1])*t;
          posArr[idxRef.val*3+2] = p1[2] + (p2[2]-p1[2])*t;
          intArr[idxRef.val] = 1.0;
          idxRef.val++;
        }
      });
    }

    function addCirclePoints(posArr, intArr, idxRef, r, cx, cy, cz, axis='y', customDensity=null) {
      const num = customDensity || Math.floor(r * 20);
      for(let k=0; k<num; k++) {
        if (idxRef.val >= MORPH_PARTICLE_COUNT) return;
        const theta = (k/num) * Math.PI * 2;
        let px=0, py=0, pz=0;
        if(axis === 'y') { px = r*Math.cos(theta); pz = r*Math.sin(theta); }
        if(axis === 'x') { py = r*Math.cos(theta); pz = r*Math.sin(theta); }
        if(axis === 'z') { px = r*Math.cos(theta); py = r*Math.sin(theta); }

        posArr[idxRef.val*3] = cx + px;
        posArr[idxRef.val*3+1] = cy + py;
        posArr[idxRef.val*3+2] = cz + pz;
        intArr[idxRef.val] = 1.0;
        idxRef.val++;
      }
    }

    // 修复: 确保包含线段终点
    function addLinePoints(posArr, intArr, idxRef, p1, p2, density=6) {
      const dist = Math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2);
      const numPoints = Math.max(2, Math.floor(dist * density));
      // 【修复】改为 k <= numPoints
      for(let k=0; k<=numPoints; k++) {
        if (idxRef.val >= MORPH_PARTICLE_COUNT) return;
        const t = k/numPoints;
        posArr[idxRef.val*3] = p1[0] + (p2[0]-p1[0])*t;
        posArr[idxRef.val*3+1] = p1[1] + (p2[1]-p1[1])*t;
        posArr[idxRef.val*3+2] = p1[2] + (p2[2]-p1[2])*t;
        intArr[idxRef.val] = 1.0;
        idxRef.val++;
      }
    }

    function addEllipsoidPoints(posArr, intArr, idxRef, rx, ry, rz, cx, cy, cz, count=200) {
      for(let i=0; i<count; i++) {
        if (idxRef.val >= MORPH_PARTICLE_COUNT) return;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);

        posArr[idxRef.val*3] = cx + rx * Math.sin(phi) * Math.cos(theta);
        posArr[idxRef.val*3+1] = cy + ry * Math.sin(phi) * Math.sin(theta);
        posArr[idxRef.val*3+2] = cz + rz * Math.cos(phi);
        intArr[idxRef.val] = 1.0;
        idxRef.val++;
      }
    }


    // --- Shape 生成 ---

    // Shape 1: Cube
    const s1 = createShapeData();
    let idx = {val:0};
    addBoxPoints(s1.positions, s1.intensities, idx, SIZE, SIZE, SIZE, 0, 0, 0);
    fillRemainingAsGhost(s1.positions, s1.intensities, idx.val);
    sortPoints(s1.positions, s1.intensities);
    shapes.push({ data: s1.positions, intensities: s1.intensities });

    // Shape 2: Möbius Strip
    const s2 = createShapeData();
    idx.val = 0;
    const mobiusStrips = 20;
    const mobiusSegments = 100;
    for(let i=0; i<mobiusStrips; i++) {
      const v = -0.8 + (i / mobiusStrips) * 1.6;
      for(let j=0; j<mobiusSegments; j++) {
        if (idx.val >= MORPH_PARTICLE_COUNT) break;
        const u = (j / mobiusSegments) * Math.PI * 2;
        const R = SIZE * 0.5; const width = SIZE * 0.3;
        const x = (R + width * v * Math.cos(u/2)) * Math.cos(u);
        const y = (R + width * v * Math.cos(u/2)) * Math.sin(u);
        const z = width * v * Math.sin(u/2);
        s2.positions[idx.val*3] = x; s2.positions[idx.val*3+1] = z; s2.positions[idx.val*3+2] = y;
        s2.intensities[idx.val] = 1.0; idx.val++;
      }
    }
    for(let j=0; j<200; j++) {
      if (idx.val >= MORPH_PARTICLE_COUNT) break;
      const u = (j / 200) * Math.PI * 2;
      const R = SIZE * 0.5; const width = SIZE * 0.3;
      const v = 1;
      let x = (R + width * v * Math.cos(u/2)) * Math.cos(u);
      let y = (R + width * v * Math.cos(u/2)) * Math.sin(u);
      let z = width * v * Math.sin(u/2);
      s2.positions[idx.val*3] = x; s2.positions[idx.val*3+1] = z; s2.positions[idx.val*3+2] = y;
      s2.intensities[idx.val] = 1.0; idx.val++;
    }
    fillRemainingAsGhost(s2.positions, s2.intensities, idx.val);
    sortPoints(s2.positions, s2.intensities);
    shapes.push({ data: s2.positions, intensities: s2.intensities });

    // Shape 3: Soccer Ball
    const s3 = createShapeData();
    idx.val = 0;
    const icoGeo = new THREE.IcosahedronGeometry(SIZE * 0.65, 1);
    const icoPos = icoGeo.attributes.position;
    const edges = {};
    for(let i=0; i<icoPos.count; i+=3) {
      const v1 = new THREE.Vector3().fromBufferAttribute(icoPos, i);
      const v2 = new THREE.Vector3().fromBufferAttribute(icoPos, i+1);
      const v3 = new THREE.Vector3().fromBufferAttribute(icoPos, i+2);
      const addEdge = (a, b) => {
        const k1 = `${Math.round(a.x*10)},${Math.round(a.y*10)},${Math.round(a.z*10)}`;
        const k2 = `${Math.round(b.x*10)},${Math.round(b.y*10)},${Math.round(b.z*10)}`;
        const key = k1 < k2 ? k1 + "_" + k2 : k2 + "_" + k1;
        if(!edges[key]) {
          edges[key] = true;
          addLinePoints(s3.positions, s3.intensities, idx, [a.x, a.y, a.z], [b.x, b.y, b.z], 8);
        }
      };
      addEdge(v1, v2); addEdge(v2, v3); addEdge(v3, v1);
    }
    fillRemainingAsGhost(s3.positions, s3.intensities, idx.val);
    sortPoints(s3.positions, s3.intensities);
    shapes.push({ data: s3.positions, intensities: s3.intensities });

    // Shape 4: UFO
    const s4 = createShapeData();
    idx.val = 0;
    addEllipsoidPoints(s4.positions, s4.intensities, idx, 2.5, 0.5, 2.5, 0, 0, 0, 600);
    addEllipsoidPoints(s4.positions, s4.intensities, idx, 1.0, 0.8, 1.0, 0, 0.4, 0, 300);
    addCirclePoints(s4.positions, s4.intensities, idx, 2.5, 0, 0, 0, 'y');
    addCirclePoints(s4.positions, s4.intensities, idx, 1.5, 0, -0.2, 0, 'y');
    addCirclePoints(s4.positions, s4.intensities, idx, 0.5, 0, -0.4, 0, 'y');
    addCirclePoints(s4.positions, s4.intensities, idx, 1.0, 0, -1.0, 0, 'y');
    fillRemainingAsGhost(s4.positions, s4.intensities, idx.val);
    sortPoints(s4.positions, s4.intensities);
    shapes.push({ data: s4.positions, intensities: s4.intensities });

    // Shape 5: Plane (修复螺旋桨)
    const s5 = createShapeData();
    idx.val = 0;
    addBoxPoints(s5.positions, s5.intensities, idx, 6.0, 0.8, 0.8, 0, 0, 0);
    addBoxPoints(s5.positions, s5.intensities, idx, 1.5, 0.1, 5.0, 0.5, 0, 0);
    addBoxPoints(s5.positions, s5.intensities, idx, 1.0, 0.1, 2.0, -2.5, 0.5, 0);
    addBoxPoints(s5.positions, s5.intensities, idx, 0.8, 1.5, 0.1, -2.5, 0.8, 0);
    // 螺旋桨圆环 (增加密度: 60点)
    addCirclePoints(s5.positions, s5.intensities, idx, 1.2, 3.0, 0, 0, 'x', 60);
    // 螺旋桨桨叶 (十字)
    addLinePoints(s5.positions, s5.intensities, idx, [3.0, 0, 1.2], [3.0, 0, -1.2], 10);
    addLinePoints(s5.positions, s5.intensities, idx, [3.0, 1.2, 0], [3.0, -1.2, 0], 10);

    fillRemainingAsGhost(s5.positions, s5.intensities, idx.val);
    sortPoints(s5.positions, s5.intensities);
    shapes.push({ data: s5.positions, intensities: s5.intensities });

    // Shape 6: Rocket
    const s6 = createShapeData();
    idx.val = 0;
    const rocketH = 4.0; const rocketR = 0.6;
    for(let y=-2.0; y<=1.0; y+=0.2) {
      addCirclePoints(s6.positions, s6.intensities, idx, rocketR, 0, y, 0, 'y');
    }
    addLinePoints(s6.positions, s6.intensities, idx, [rocketR, -2, 0], [rocketR, 1, 0], 8);
    addLinePoints(s6.positions, s6.intensities, idx, [-rocketR, -2, 0], [-rocketR, 1, 0], 8);
    addLinePoints(s6.positions, s6.intensities, idx, [0, -2, rocketR], [0, 1, rocketR], 8);
    addLinePoints(s6.positions, s6.intensities, idx, [0, -2, -rocketR], [0, 1, -rocketR], 8);
    for(let k=0; k<=10; k++) {
      const t = k/10; const r = rocketR * (1-t); const y = 1.0 + t * 1.5;
      addCirclePoints(s6.positions, s6.intensities, idx, r, 0, y, 0, 'y');
    }
    for(let k=0; k<3; k++) {
      const angle = (k/3) * Math.PI * 2;
      const x = Math.cos(angle) * rocketR; const z = Math.sin(angle) * rocketR;
      const tx = Math.cos(angle) * (rocketR + 0.8); const tz = Math.sin(angle) * (rocketR + 0.8);
      addLinePoints(s6.positions, s6.intensities, idx, [x, -1.0, z], [tx, -2.5, tz], 10);
      addLinePoints(s6.positions, s6.intensities, idx, [x, -2.0, z], [tx, -2.5, tz], 10);
      addLinePoints(s6.positions, s6.intensities, idx, [tx, -2.5, tz], [x, -2.5, z], 5);
    }
    fillRemainingAsGhost(s6.positions, s6.intensities, idx.val);
    sortPoints(s6.positions, s6.intensities);
    shapes.push({ data: s6.positions, intensities: s6.intensities });

    // Shape 7: Ship
    const s7 = createShapeData();
    idx.val = 0;
    addBoxPoints(s7.positions, s7.intensities, idx, 6.0, 1.0, 1.8, 0, -1.5, 0);
    addBoxPoints(s7.positions, s7.intensities, idx, 1.5, 0.8, 1.8, 2.5, -0.8, 0);
    addLinePoints(s7.positions, s7.intensities, idx, [0, -1.0, 0], [0, 3.5, 0], 15);
    addLinePoints(s7.positions, s7.intensities, idx, [-2.0, -1.0, 0], [-2.0, 2.0, 0], 15);
    addLinePoints(s7.positions, s7.intensities, idx, [0, 0, 0], [0, 0, 2.0], 10);
    addLinePoints(s7.positions, s7.intensities, idx, [0, 3.0, 0], [0, 3.0, 1.5], 10);
    addLinePoints(s7.positions, s7.intensities, idx, [0, 0, 2.0], [0, 3.0, 1.5], 8);
    addLinePoints(s7.positions, s7.intensities, idx, [0, 0.5, 0], [0, 0.5, -1.8], 10);
    addLinePoints(s7.positions, s7.intensities, idx, [0, 2.5, 0], [0, 2.5, -1.2], 10);
    addLinePoints(s7.positions, s7.intensities, idx, [0, 0.5, -1.8], [0, 2.5, -1.2], 8);
    addLinePoints(s7.positions, s7.intensities, idx, [0, 3.0, 0], [3.0, -1.0, 0], 6);
    fillRemainingAsGhost(s7.positions, s7.intensities, idx.val);
    sortPoints(s7.positions, s7.intensities);
    shapes.push({ data: s7.positions, intensities: s7.intensities });

    // Shape 8: Monkey Head (修复耳朵)
    const s8 = createShapeData();
    idx.val = 0;
    // 头骨
    addEllipsoidPoints(s8.positions, s8.intensities, idx, 1.3, 1.1, 1.2, 0, 0.2, 0, 600);
    // 嘴部
    addEllipsoidPoints(s8.positions, s8.intensities, idx, 0.8, 0.6, 1.0, 0, -0.5, 0.8, 300);
    // 耳朵 (增强) - 使用多重圆环增加厚度，并提高点数
    for(let offset=0; offset<0.3; offset+=0.1) {
      addCirclePoints(s8.positions, s8.intensities, idx, 0.8-offset, 1.4+offset/2, 0.2, 0.3, 'x', 60); // 左耳
      addCirclePoints(s8.positions, s8.intensities, idx, 0.8-offset, -1.4-offset/2, 0.2, 0.3, 'x', 60); // 右耳
    }
    // 眼睛
    addEllipsoidPoints(s8.positions, s8.intensities, idx, 0.4, 0.4, 0.3, 0.5, 0.3, 1.1, 150);
    addEllipsoidPoints(s8.positions, s8.intensities, idx, 0.4, 0.4, 0.3, -0.5, 0.3, 1.1, 150);
    // 眉弓
    addLinePoints(s8.positions, s8.intensities, idx, [0.2, 0.7, 1.1], [0.8, 0.5, 1.0], 8);
    addLinePoints(s8.positions, s8.intensities, idx, [-0.2, 0.7, 1.1], [-0.8, 0.5, 1.0], 8);

    fillRemainingAsGhost(s8.positions, s8.intensities, idx.val);
    sortPoints(s8.positions, s8.intensities);
    shapes.push({ data: s8.positions, intensities: s8.intensities });


    // --- 5. 动画与交互控制 ---
    let mouseX = 0, mouseY = 0;
    let windowHalfX = window.innerWidth / 2;
    let windowHalfY = window.innerHeight / 2;

    document.addEventListener('mousemove', (e) => {
      mouseX = (e.clientX - windowHalfX) * 0.001;
      mouseY = (e.clientY - windowHalfY) * 0.001;
    });
    document.addEventListener('touchmove', (e) => {
      mouseX = (e.touches[0].clientX - windowHalfX) * 0.002;
      mouseY = (e.touches[0].clientY - windowHalfY) * 0.002;
    });
    window.addEventListener('resize', () => {
      windowHalfX = window.innerWidth / 2;
      windowHalfY = window.innerHeight / 2;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    currentPositions.set(shapes[0].data);

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      const totalTime = clock.getElapsedTime();

      timeAccumulator += delta;

      // --- 1. 更新背景星云 (闪烁逻辑) ---
      const bgColAttr = bgSystem.geometry.attributes.color;
      for (let i = 0; i < BG_PARTICLE_COUNT; i++) {
        const brightness = 0.3 + 0.5 * (Math.sin(totalTime * 1.5 + bgPhases[i]) + 1) / 2;
        bgColAttr.array[i*3] = brightness;
        bgColAttr.array[i*3+1] = brightness;
        bgColAttr.array[i*3+2] = brightness;
      }
      bgColAttr.needsUpdate = true;

      // --- 2. 变形逻辑 ---
      let morphFactor = 0;
      let phase = "STAY";

      const cycleTime = MORPH_DURATION + STAY_DURATION;
      const currentCycleTime = timeAccumulator % cycleTime;

      if (currentCycleTime < STAY_DURATION) {
        phase = "STAY";
        morphFactor = 0;
      } else {
        phase = "MORPH";
        morphFactor = (currentCycleTime - STAY_DURATION) / MORPH_DURATION;
      }

      const newIndex = Math.floor(timeAccumulator / cycleTime) % shapes.length;
      if (newIndex !== currentShapeIndex) {
        currentShapeIndex = newIndex;
        nextShapeIndex = (currentShapeIndex + 1) % shapes.length;
        uiStatus.innerText = `MORPHING: ${shapeNames[currentShapeIndex]} > ${shapeNames[nextShapeIndex]}`;
      }

      const ease = phase === "MORPH"
        ? morphFactor * morphFactor * (3 - 2 * morphFactor)
        : 0;

      const currentShape = shapes[currentShapeIndex];
      const nextShape = shapes[nextShapeIndex];

      const posAttr = morphSystem.geometry.attributes.position;
      const colAttr = morphSystem.geometry.attributes.color;

      for (let i = 0; i < MORPH_PARTICLE_COUNT; i++) {
        const idx3 = i * 3;

        // 位置插值
        const x1 = currentShape.data[idx3], y1 = currentShape.data[idx3+1], z1 = currentShape.data[idx3+2];
        const x2 = nextShape.data[idx3], y2 = nextShape.data[idx3+1], z2 = nextShape.data[idx3+2];

        let tx = x1 + (x2 - x1) * ease;
        let ty = y1 + (y2 - y1) * ease;
        let tz = z1 + (z2 - z1) * ease;

        tx += Math.sin(totalTime * 3 + y1) * 0.01;
        ty += Math.cos(totalTime * 2.5 + x1) * 0.01;
        tz += Math.sin(totalTime * 2 + z1) * 0.01;

        posAttr.array[idx3] = tx;
        posAttr.array[idx3+1] = ty;
        posAttr.array[idx3+2] = tz;

        // 亮度插值
        const i1 = currentShape.intensities[i];
        const i2 = nextShape.intensities[i];
        const currentIntensity = i1 + (i2 - i1) * ease;

        // 颜色计算
        const twinkle = 0.6 + 0.4 * Math.sin(totalTime * 8 + i * 0.2);

        colAttr.array[idx3] = 1.0 * twinkle * currentIntensity;
        colAttr.array[idx3+1] = 1.0 * twinkle * currentIntensity;
        colAttr.array[idx3+2] = 1.0 * twinkle * currentIntensity;
      }

      posAttr.needsUpdate = true;
      colAttr.needsUpdate = true;

      // 旋转控制
      morphSystem.rotation.y += 0.005;
      morphSystem.rotation.x += (mouseY * 0.8 - morphSystem.rotation.x) * 0.05;

      bgSystem.rotation.y = morphSystem.rotation.y;
      bgSystem.rotation.x = morphSystem.rotation.x;

      renderer.render(scene, camera);
    }

    animate();
  })();
</script>
</body>
</html>