---
id: 3092
title: "JAVA基础"
date: 2014-09-30T08:50:30.000Z
categories:
  - "first-category"
---

终于看完了马士兵老师JAVA视频的基础部分，记录一下，接下来想个项目来做下练练手。

### 程序

- 过程
- 数据结构
- 对象
- 算法

### JAVA初

- 环境
- - path
- - - copy 路径最好复印过去
- - classpath
- - IDE
- 格式
- - 让别人看得舒服
- - 让别人看得清楚
- - 运算符两侧加空格
- - 并排语句加空格
- - 大括号对齐
- - 程序块之间加空行
- - 缩进
- - 成对编程
- - { 左侧有空格
- 编译-运行
- - java
- - javac
- - java -version
- 一个类只能有一个 public class
- - 且与文件名相同
- - psvm 是入口
- 知识管理
- - 记录每一个错误
- - 多看，多写，例子程序

<!--more-->

### JAVA语法

- 作用域
- - 出了大括号无作用
- 标识符
- - 关键字
- 基础数据类型（4类8种）
- - 逻辑型 boolean
- - - 只有TRUE和FELASE
- - 文本型 char
- - - 二个字节有16位，所以可以用十六进制Unicode表示
- - - 转义字符 ‘\\’
- - 整数型 byte 1, short 2, int 4, long 8
- - - 十进制 123
- - - 八进制 012
- - - 十六进制 0x
- - - 默认为 int
- - - long 888888L
- - 浮点数型 float 4, double 8
- - - 默认 double
- - - float 12.3F
- 常量（数据类型）
- - (在别的语境中表示不可变的变量)
- - 123
- - ‘a’
- - “hello world”
- - 3.14
- - true
- 变量
- - 先声明，再赋值
- - 成员变量
- - 局部变量
- 基本数据转换
- - boolean 不可以转换
- - 整形、字符型、浮点 在混合运算中可以相互转换
- - - byte, shote, char -> int -> long -> float ->double
- - - byte, short, char 运算时都要先自转 int
- - - 容量大转容量小，要用强制转换符，可能会有精度降低或溢出
- - - 多种类型混合运算时，系统自动将所有数据转换成容量最大的
- - - 实数常量（1.2） 默认为double
- - - 整数常量（123）默认为 int
- 程序执行中的内存
- - heap NEW出来的东西
- - stack 局部变量
- - data segment 静态变量 字符串变量
- - code segment 存放代码

### 运算符

- 位运算符 & | ^ ~ >> << >>>
- 赋值运算符 =
- 逻辑运算符 ! & | ^ && ||
- - && ||短路
- - ^逻辑异或
- 算术运算符 + - \* / % ++ —
- - 自加（减）运算符 ++ —
- - - 在前 先运算再取值
- - - 在后 先取值再运算
- 关系运算符 > < >= <= == !=
- 字符串连接运算符 +
- - 字符串转换
- - 当进行打印时，无论任何类型，都自动转为字符串
- 扩展赋值运算符 += -+ \*= /=

### 分支与循环

- if
- - 注意省略大括号时，有且只能有一句话。全都把括号写上。
- for
- - i 是一个局部变量
- while
- - 变量声明一次，多次使用
- - - 循环体可能不执行
- 读别人程序
- - 分析内存
- - - 1 + 1_2 + 1_2\*3
- - - 循环一次写一行
- - 多读别人的算法
- break & continue
- - 注意 if 语句后面不要有分号
- - continue 中止本次循环
- 优秀程序
- - 程序要健壮，鲁棒性
- - 大量的注释文档
- switch
- - 一般要写 break
- - 多个 case 可以合并
- - default 不要省略
- - 只能探测 int 类型值

### 方法

- 也叫函数
- 用于复用
- 分解复杂任务
- 传递参数时，遵循值传送原则
- - 基本类型传递的是该数据值本身
- - 引用类型传递的是对对象的引用，而不是对象本身
- 只有执行时能使用内存
- 格式
- - 形式参数
- - - 定义好类型
- - 实参
- - 返回值
- - 返回值类型
- - - 如无返回值，则用 void
- 递归调用
- - 遇到方法即会执行方法，等待返回值后再继续
- - 无分支
- - 方法执行时出现本身的调用
- - 递归中有多少个方法同时执行 Fibonacci数列
- - 画图理解
- 使用
- - 对象名。方法名（实参列表）
- - 实参要匹配
- - return 终止方法的运行并指定要返回要数据

### 面向对象

- 1，首先思考问题域中有多少个对象
- 2，然后让合适的属性和方法出现在合适的对象里
- 设计思想
- - 面向过程
- - 面向对象
- - - 我命令车去新疆
- - - 车怎么去不关我事
- - - - 信息封装在车这个类的内部
- - - - 我不用去了解车整个开动的过程
- - 在系统的构造中尽可能的运用人类的自然思维方式
- - 强调运用人类常用的思想方法与原则 ：抽象、分类、继承、聚合、多态
- 为什么用对象
- - Reusable
- - Extensibility
- - 维护和替换更加方便
- 3，再思考类（对象）之间的关系
- - 关联关系
- - - 有一点，但不紧密
- - - 我的某一方法参数是另一对象
- - 继承关系
- - - XX是一种X
- - - - 学生是一种人
- - - 可产生继承树
- - - JAVA无多重继承
- - 聚合关系
- - - XX是XX的一部分
- - - - 手是人的一部分
- - - 聚合
- - - - 球队与队员
- - - 组合
- - - - 人与身体器官
- - 实现关系
- - - 我有一个方法，怎么实现由子类去实现
- - - 多态
- 抽象对象的方法
- - 与业务逻辑无关的不封装
- - 抽象出下面系统中的类及关系
- - - 用户去旅行社订机票
- - - 我要去新疆
- - 找名词
- - 万事万物皆对象
- - 类是用来创建同一类型的对象的“模板”，在一个类中定义了该类对象所应具有的成员变量以及方法
- - 首先定义类才有对象
- - 首先定义方法才能调用
- - 静态属性（成员变量，属性）
- - 动态属性（方法，函数）
- 类与对象
- - 类可以看成一类对象的模板，对象可以看成该类的一个具体实例
- - attribute 成员变量 属性
- - - 一般对象的成员变量不一样
- - method
- - 实例 对象 Object

### 面向对象基础概念

- 成员变量
- - 先声明，再赋值
- - 可以是JAVA语言中的任何一种数据类型
- - 成员变量都有初始化值
- - 作用范围为整个类体
- 内存图是什么样的？会画不？
- 创建和使用
- - 必须使用new创建对象
- - 使用 对象（引用）。成员变量 来引用对象的成员变量
- - 使用 对象（引用）。方法（参数列表） 来调用对象的方法
- - 同一类的每个对象有不同的成员变量存储空间
- - 同一类的每个对象共享该类的方法
- 引用
- - 除基本类型外都是引用类型
- - 占用两块内存
- - 都是指针
- - 类是静态的概念，代码区
- - 对象是new出来的，在堆内存
- - 类的成员变量在不同对象中有不同的值
- - 方法只有一份，执行时才占用内存
- - 一小块内存指向一大块内存

### 构造方法（构造函数）

- 构造函数与类同名且没有返回值
- 构造函数是定义在Java类中的一个用来初始化对象的函数
- 使用 new & 构造方法 创建一个新的对象
- \_id \_age 使用下划线区别形参与成员变量名
- 没有指定构造函数时，系统自动有一个空的构造方法
- 内存图会画不？
- 一但自己定义了构造方法，系统不再有空的构造方法
- 构造方法前面没有返回值

### 全名规则

- 类名首字母大字
- 驼峰标识
- 变量名和方法名首字母小字

### 内存

- 栈
- - 使用完就销毁
- 方法只能通过NEW出来的对象来调用
- 堆
- - 内存回收时销毁

### 方法的重载

- 类中名字相同，参数不同的多个方法
- - 个数不一样
- - 或类型不一样
- 返回值不一样不能重载
- 调用时会根据不同的参数表选择对应的方法

### 对象的创建和使用

- 同一类的每一个对象共享该类的方法
- - 非静态方法是针对每个对象进行调用
- 同一类的每个对象有不同的成员变量存储空间
- 必须使用 new 关键字创建对象
- 使用 对象引用。方法（参数列表）来调用对象的方法
- 使用 对象引用。成员变量 来引用对象的成员变量

### 读代码

- 遇到复杂表达式，从内向外分析
- 分析内存是易筋经

### 写方法（计算在没在圆中）

- 方法的名字
- - 想下别人怎么用
- - - 第三人称
- - - 英文的说话习惯
- 方法的形参
- - 包不包含某个点，所以传一个点进来
- 方法的返回值
- - 是不是，返回布尔

### this

- 类中的this代表该方法的对象的引用
- 在必须指出当前使用方法的对象是谁是要使用this
- this指向他自己
- this可以看作是一个变量，他的值是当前对象的引用
- 有时使用this要以处理方法中成员变量与参数重名的情况
- 就近原则
- - i 就是最近声明的 i

### static

- 放在数据区data seg
- 该类的静态成员变量
- 没有对象也能访问，类。XXX
- 该类的公用变量
- 字串符常量放在data seg
- 对于该类的所有对象来说，static成员变量只有一份
- 计数用
- 在static方法中不可访问非static的成员变量

### package

- 用。指明句层次
- 对应目录管理
- 包中的类，必须Java源文件的第一条语句
- 解决类名冲突
- 编译出来的CLASS必须位于正确的位置
- import
- - 要使用也必须把包层次写正确
- - 也可引入
- - 访问同一包中的其他类，不用引入
- - 想要引入正确必须CLASSPATH设置正确
- - - CLASS文件的最上层包的父目录位于CLASSPATH
- - 执行一个类需要写全包名
- 常用包
- - /jdk/Contents/Home/jre/lib/rt.jar
- - - java.lang
- - - - 无需引入直接使用
- - - java.awt
- - - java.net
- - - java.io
- - - java.util
- - 打包，方便给别人用
- - - jar -cvf test.jar _._
- - - 把jar设置到CLASSPATH中

### 类的继承 & 访问控制

- 成员 权限修饰符
- - private
- - - 类内部
- - default
- - - 同一个包 默认
- - protected
- - - 子类
- - public
- - - 任何
- 类的继承
- - 使用 extends 实现类的继承
- - 通过继承，子类自动拥有基类（superclass）的所有成员（成员变量和方法）
- - JAVA只支持单继承
- - 在内存中子类对象会包着基类对象
- - 方法的重写
- - - 在子类对基类继承的方法进进行重写
- - - 注意大小写，就不是重写，而是一个新方法
- - - - 复制方法名过去
- - - 重写必须有相同的方法名、形参、返回类型
- - - 重写方法不能使用比被重写方法更严格的访问权限
- - super
- - - super引用基类（父类）的对象
- - - this引用当前类的对象
- 类 权限修饰符
- - default
- - - 同一个包 默认
- - public
- - - 任何

### 继承中的构造方法

- 子类的构造过程 必须 调用基类的构造方法
- 子类可以在自己的构造方法中使用 super(argument_list) 调用基类的构造方法
- - 使用this(argument_list)调用本类另外的构造方法
- - 如果调用了super，必须写在子类构造方法的第一行
- argument_list 注意顺序
- 字符串在在date seg区，通过引用指向他们
- 如果子类的构造方法中没有显示地调用基类构造方法，则系统默认调用基类无参数的构造方法
- - 不写 就是 自动调用 super()
- 如果子类构造方法中即没有显式调用基类构造方法，而基类中又没有无参的构造方法，则编译出错

### Object

- 所有类的根类
- equals()
- - 提供定义对象是否“相等”逻辑
- - x.equals(y)
- - String 重写了
- toString()
- - 多读英文文档
- - 推荐重写这个方法
- hashcode

### 对象转型casting

- 一个基类的引用 类型变量可以“指向”其子类 的对象
- 一个基类的引用不可以访问其子类对象新增加的成员（属性和方法）
- Animal a = new Dog()
- 可以使用 引用 变量 instanceof 类名 来判断该引用型变量所“指向”的对象是否属于该类或该类的子类
- 传基类进来，再按不同子类做逻辑
- - 面向对象：可扩展性好
- 子类的对象可以当作基类的对象来使用称作向上转型（upcasting），反之向下转型（downcasting）

### 动态绑定、多态、吃绑定

- 动态绑定是指在执行期间判断所引用对象类型，根据其 实际类型 调用其相应的方法
- - 小姑娘养了一只宠物
- - 实际类型
- - 不是引用类型
- - new 时 才确定调用哪个方法 猫。猫叫
- 雷电游戏
- - 扩展性好
- - GAMEOBJECT
- - - 敌机
- - - 鞭子
- - - 子弹
- - - 我们的飞机
- 使用条件
- - 要有继承
- - 要有重写
- - 父类引用指向子类对象

### 抽象类

- 用 abstract 修饰的类
- - 用 abstract 修饰的方法
- 含抽象方法的必须声明为抽象类
- - 抽象类必须被继承
- - 抽象方法必须被重写
- 子类也可是抽象类
- - 交给子类去实现
- 不能被实例化
- 只需要声明，不需实现

### final

- final 的变量的值不能被改变
- - final 的成员变量
- - final 的局部变量（形参）
- - 只能读不能写
- final 的方法不能被重写
- final 的类不能被继承

### interface

- 多个无关的类可以实现同一个接口
- 每一个接口暴露对象的某一部分方法！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
- 一个类可以实现多个无关的接口
- 与继承关系类似，接口与实现类之间存大多态性
- 接口（interface）是抽象方法和常量值的定义的集合
- 从本质上讲，接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有变量和方法的实现
- 接口特性
- - 接口可以多重实现
- - 接口中声明的属性默认为 public static final 的，也只能是 public static final 的
- - 接口中只能定义抽象方法，而且这些方法默认是 public 的，也只能是 public 的
- - 接口可以继承其它的接口，并添加新的属性和抽象方法
- public interface Runner{ public static final int id = 1; }
- implements

### 异常调试

- 有的方法有 throws
- - 一定要处理异常
- 异常的分类
- - Throwable
- - - Error(不可处理)
- - - Exception（可处理）
- - - - RuntimeException（常见，可处理，但可无视）
- - - - 方法中有 throws 的（一定要处理）
- 理论
- - 在程序运行期出现的错误
- - JAVA异常是JAVA提供的用于处理程序中错误的一种机制
- - 所谓错误是指在程序运行的过程中发生的一些异常事件（如：除0溢出、数组下标越界、要读取的文件不存在）
- - 设计良好的程序应该在异常发生时提供处理这些错误的方法，便得程序不会因为异常的发生而阻断或产生不可预见的结果
- - JAVA程序的执行过程如出现异常事件，可以生成一个异常类对象，该异常对象封装了异常事件的信息并将被提交给JAVA运行时系统，这叫 抛出（throw） 异常
- - 当JAVA运行时系统接收到异常对象时，会寻找能处理这一异常的代码并把当前异常对象交给其处理，这一过程称为 捕获（catch）异常
- 用法
- - try 可跟多个 catch
- - - catch到异常一定要处理
- - - printStackTrace()
- - - getMassage()
- - - 先子后父
- - finally
- - - 产不产生异常都会执行
- - - 进行资源的清除工作
- - - - 关闭打开的文件
- - - - 删除临时文件
- - - 里面可继续 try
- 不想处理异常都可以抛出，轻易不抛
- 自定义异常
- - 继承java.lang.Exception来声明自己的异常类
- - 在方法适当的位置 生成自定义异常的实例，并用throw语句抛出
- - 在方法的声明部分用 throws 语句声明该方法可能抛出的异常
- - 重写方法需要抛出与原方法所抛出异常类型一致异常或不抛出异常

### 数组

- 用法
- - arr\[i\]
- System.exit(-1)
- - JVM非正常关闭
- 算法
- - 找规律
- - 选择排序
- - - 画图理解
- - - 二次优化
- - 冒泡排序
- 理论
- - 声明时不能指定其长度
- - 使用 new 创建数组对象
- - 动态初始化
- - - 数组定义
- - - 与数组元素分配空间
- - - 和赋值的操作分开进行
- - 静态初始化
- - - 定义数组的同时就为数组元素分配空间并赋值
- - 元素初始化按成员变量隐式初始化
- - .length 是属性不是方法
- printlnth会自动调用toString方法
- 思考题
- - 数三退一，最后哪个人在哪个位置
- - 面向对象的写法？
- 链表
- 二分法查找
- 二维数组
- - 静态初始化
- - 动态初始化
- - - 先空间
- - arraycopy
- - - 指向同一内存中的值，一改都改

### 常用类

- 基础类型包装类
- - 封装一个相应的基本数据类型数值成为对象，并为其提供了一系列操作
- String
- - 没有 new 就会指向同一个内存
- - 有 new 会两个不同的内存
- - 不可变的字条序列
- - 正则表达式
- Math
- - 提供一系列静态方法用于科学计算，其方法的参数和返回值类型一般为double型
- StringBuffer
- - 代表可变的字符序列
- File
- - separator
- - - 兼容性好
- - 递归
- 经常查询API文档
- Enum枚举
- - 出错越早越好
- - 像是静态变量
- - 只能写之前定义好的值之一

### 容器

- JAVA API 所提供的一系列类的实例，用于在程序中存放对象
- 1136
- - 一个图
- - 一个类
- - - Collections
- - 三个知识点
- - - For
- - - Generic
- - - Auto-boxing/unboxing
- - 六个接口
- - - Collection
- - - Set
- - - List
- - - Map
- - - Iterator
- - - Comparable
- Collection接口
- - Set
- - - 无序，不可重复
- - - remove contains 主要看是否equals 和 hashCode
- - - - 重写equals一定也要重写hashCode
- - - - 字典会用到hashCode
- - - - 相同对象有相同的hashCode
- - List
- - - 有序，可重复（equals）
- - - 使用父类引用指向子类对象，灵活方便
- - - for(int i:arr)
- - - - 不方便访问下标I
- - Iterator
- - - 所有实现Collection接口都有Iterator方法实现Iterator接口的对象
- - - 迭代器
- - - 就是指针、游标
- - - 理解多态
- - - 在循环时锁定，只能用 I，对象自己的相关方法不能用
- Collections类
- - 常用算法（排序，查找）
- - Comparable接口
- - - 把对象当接口
- - - compareTo
- 泛型
- - Collection
- - 看文档中有<>
- - 集合时尽量使用泛型
- Map
- - 用来存储（键：值）对
- - HashMap
- - - hash做索引
- - TreeMap
- - - 二叉树做索引
- - 值通过键做标识，所以键值不能重复
- - - 通过equals和hashCode比较
- - - - 两个要同时修改
- - Auto-boxing/unboxing
- 如何选择
- - Array读快改慢
- - Linked改快读慢
- - Hash两者之间

### 流（Stream）

- 如同接水管一样，接上 开始流
- - 在IO包中
- 输入输出
- - InputStream
- - - read(byte\[\] buffer)
- - OutputStream
- - - 先flush()再close()
- 转换流
- - FileOutputStream()
- - - OutputStreamWriter
- - - - 转化后方便写入中文字符
- - System.in
- - - InputStreamReader
- - - - BufferedReader
- - - - - readLine()
- - - - - - 阻塞式
- - - - - - 同步
- 字节字符
- - Reader
- - - FileReader
- - Writer
- - - FileWriter
- 数据流
- - ByteArrayOutputStream
- - - DataOutputStream
- - - - writeDouble
- - - - writeBoolean
- - - ByteArrayInputStream
- - - - DataInputStream
- - - - - readDouble
- - - - - readBoolean
- - 队列
- - - 先进先出
- 节点处理
- - 节点流
- - - 字节流
- - - 字符流
- - - - FileReader
- - - - FileWriter
- - 处理流
- - - 缓冲流
- - - - BufferedWriter
- - - - BufferedReader
- - - - - readLine()
- Print流
- - 画图理解
- - FileOutputStream
- - - PrintStream
- - - - System.setOut
- - - - sout是PrintStream类型
- - 自带flush
- Object流
- - 序列化
- - Serializable
- - - 标记类接口，给编译器看，不用实现方法
- - - transient
- - - - 序列化时不记录
- - - Externalizable
- - - - 自定义序列化
- - ObjectInputStream

### 线程

- 概念
- - 线程是一个程序中不同的执行路径
- - java.lang.Thread
- - - run()
- - - start()
- 线程同步
- - 访问同一资源的多个线程之间的协调
- - - 线程打断时，前后不一致
- - synchronized(this)
- - - synchronized void add()
- - - - 锁定当前对象
- - - 互斥锁
- - - - 某个时间段只进到一个方法体中
- - 死锁
- - - 哲学家吃饭问题
- - - 只锁一个对象
- - - 锁的颗度加粗
- - 要考虑到所有能访问同一资源的方法
- - - 给所有方法都加锁
- - 给改的方法加锁
- - - 读可以不加
- - this.wait()
- - - 发生阻塞时
- - - if 改用 while
- - - this.notify()
- - - - 叫醒一个wait的对象
- - - notifyAll()
- - - - 多个线程
- - - 锁不再归我所有
- 方法
- - implements Runnable
- - - t=thread(r)
- - - - t.start()
- - - - - 最好用这种
- - extends Thread
- - - r.start()
- - sleep(888)
- - - 暂停执行888毫秒
- - - 关闭线程用一个标记来关
- - join()
- - - 合并某个线程
- - yield()
- - - 高风亮节让出CPU
- - setPriority(Thread.NORM_PRIORITY + 3)
- - - 默认优先级提升3
- - currentThread().isAlive()
- - - 当前线程状态

### 网络编程

- 概念
- - 通信协议分层
- - - IP
- - - TCP
- - - UDP
- - socket编程
- - - 插座
- - - 双向的网络通信实现数据交换
- - - client-server
- - - - Socket
- - - - ServerSocket
- 用法
- - TCP
- - - new Socket(’127.0.0.1’, 888)
- - - - getOutputStream()
- - - - - DateOutStream()
- - - - - - writeUTF
- - - new ServerSocket(888)
- - - - accept() 阻塞式
- - - - - 死循环
- - - - - - getInputStream()
- - - - - - - DateInputStream()
- - - - - - - - readUTF 阻塞式
- - Socket
- - - 不能都读，所在首先有一个先写
- - - 都有OUT/IN
- - UDP
- - - client
- - - - InetSocketAddress
- - - - - DatagramPacket
- - - - - - DatagramSocket
- - - server
- - - - DatagramPacket
- - - - - DatagramSocket
- - - LONG转byte数组
- - - - ByteArrayOutputStream
- - - - - DataOutputStream
- - - - - - writeLong
- - - byte数组转LONG
- - - - ByteArrayInputStream
- - - - - DataInputStream
- - - - - - readLong

### GUI编程

- Graphics
- - Component都有一个paint用于实现绘图，每次重画该Component时都自动调用paint方法
- - 画图重写paint(Graphics g)
- - update(Graphics g)
- - repaint()
- 事件监听
- - 原理
- - - 事件源对象
- - - 实现某种监听器接口的类的对象
- - ActionEvent
- - - Button
- - - - addActionListener
- - - - implements ActionListener
- - - TextField
- - - - e.getSource()
- - - - - getText()
- - MouseEvent
- - - extends MouseAdapter
- - - - 继承可以不用重写五种方法
- - - addMouseListener
- - WindowEvent
- - - extends WindowAdapter
- - - - 适配器
- - - addWindowListener
- - KeyEvent
- - - e.getKeyCode()
- - - - 看返回值
- AWT
- - Component
- - - Container
- - - - Windows
- - - - - Frame
- - - - - - Panel
- - - - - Dialog
- - - - - pack()
- - - - - setVisible()
- 布局管理器(LayoutManager)
- - FlowLayout
- - BorderLayout
- - - default
- - GridLayout
- 内部类
- - 持有对方引用 this
- - - 门面(外观)模式Facade
- - 定义在类中的类
- - 可以访问包装类的成员变量、方法
- - - 默认有外部类的引用
- - 该类不允许或不需要其它类进行访问时
- - 编译后有$
- 匿名内部类
- - 逻辑简单，不常变，时使用
- - 继承或实现接口，重写或实现其方法时

### 日期处理

- Calendar
- SimpleDateFormat

### 反射机制

- 反射机制
- - 在运行时加载、探知、使用编译期完全未知的classes
- - java.lang.reflect
- - properties
- - - JAVA的一种配置文件
- - class.forName(Str)
- - - newInstance()
- - - - getMethods()
- - - - - invoke()
- - - - - - 可变参数
- ClassLoader
- - \-verbose:class
- - 概念
- - - 并非一次性加载
- - - 需要时加载
- - - static语句块在加载后执行一次
- - - dynamic语句块每次new新的对象都会执行
- - JDK
- - - bootstrap class loader
- - - extension class loader
- - - application class loader
- - - other class loaders
- - - 是层次不是继承
- - - getClassLoader()
- - - - getParent()
- - 在load时先找上一层loader，如果已经load，就不再load
- - - 安全性好，破坏性代码无机会执行

### 工厂模式 FactoryMethod

- 单态模式
- - 保证一个类仅有一个实例，并提供一个访问它的全局访问点。
- 静态工厂方法
- - 定义一个用于创建对象的接口，让子类决定实例化哪一个类。使一个类的实例化延迟到其子类。
- - 工厂产生对象
- - 构造方法一般 private
- - getInstance()
- 抽象工厂
- - 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类
- - - 方便修改各种配置
- - - 定义公用接口
- - - - 实现
- - AbstractFactory
- - - 声明抽象产品对象的操作接口
- - ConcreteFactory
- - - 实现创建具体产品对象的操作
- - AbstractProduct
- - - 为一类产品对象声明一个接口
- - ConcreteProduct
- - - 定义一个将被相应的具体工厂创建的产品对象
- - - 实现AbstractProduct接口
- - Client
- - - 仅使用AbstractFactory和AbstractProduct类声明的接口
- 简单工厂
